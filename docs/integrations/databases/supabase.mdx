---
title: Integrate Supabase with Clerk
description: Learn how to integrate Clerk into your Supabase application.
---


<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/quickstarts/setup-clerk",
    },
  ]}
>

- Use Clerk to authenticate access to your Supabase data
- Customize a JWT template to suit your use-case with Supabase
- Further protect your Supabase data with an RLS policy

</TutorialHero>

## Quickstart

You can use Clerk's [JWT templates](/docs/backend-requests/making/jwt-templates#jwt-templates) to authenticate users before giving them access to your Supabase data. Doing so enables you to protect your data from unexpected changes with Supabase's [Row Level Security](https://supabase.com/docs/guides/auth/row-level-security) while leveraging Clerk's webhooks, prebuilt components, and out-of-the-box security features like bot detection.

<Steps>
 
### Configure your Supabase project's RLS policies

It is recommended that you enable Supabase's Row Level Security (RLS) for your databases. To access the contents of a database from within your app, you must add an RLS policy to allow your database to be read.

To do so:

1. [Visit the Supabase dashboard](https://supabase.com/dashboard/projects) and select your project.
1. In the sidebar, select **Authentication** â†’ **Policies**. Select the **New Policy** button.
1. Select **For full customization** to create your own policy.
    - Set the policy name to "Enable read for authenticated visitors".
    - Choose **SELECT** for the **Allowed operation**.
    - In the **Targeted roles** dropdown, select `authenticated`.
    - In **USING expression**, enter `true`.
    - Finally, select **Review**. Then, select **Save policy**.

<Callout type="info">

  This policy gives full database read access to _any_ visitor to your app who authenticates through Clerk. To limit each user's access to only their data, see the section below on accessing user IDs in RLS policies.

</Callout>

### Get your Supabase JWT secret key

To give users access to your data, Supabase's API requires an access token to authenticate requests. Your Clerk project can generate these access tokens, but needs your Supabase project's JWT secret key first.

To find it:

1. Select your project from your Supabase dashboard.
1. In the sidebar, select **Settings** â†’ **API**. Copy the value in the **JWT Secret** field.
1. Open [the Clerk dashboard](https://dashboard.clerk.com/) in a new tab.

### Create a Supabase JWT template

Clerk's JWT templates allow you to generate a new valid Supabase access token for each signed in user. These tokens allow authenticated users to access your data with Supabase's API.

To create a JWT template for Supabase:

1. Open your project in the Clerk Dashboard and navigate to the **JWT Templates** page in the sidebar.
2. Select the **New template** button, then select **Supabase** from the list of options.
3. Configure your template:
    - The value of the **Name** field will be required when using the template in your code. In general, you should name the template after the database you're connecting it to. For this quickstart, name it `supabase`. 
    - **Signing algorithm** will be `HS256` by default. This algorithm is required to use JWTs with Supabase. [Learn more in their docs](https://supabase.com/docs/guides/resources/glossary#jwt-signing-secret).
    - Under **Signing key**, add the value of your Supabase **JWT secret key** from the previous step. 
    - Leave all other fields at their default settings unless you want to customize them. See [Clerk's JWT template docs](/docs/backend-requests/making/jwt-templates#creating-a-template) to learn what each of them do.
    - Select **Apply changes** to complete setup.

### Set up your local project

To use Clerk with Supabase in your code, first install the necessary SDKs by running the following terminal command in the root directory of your project:

<Tabs type="framework" items={["Next.js", "React"]}>
  <Tab>
    <CodeBlockTabs type="installer" options={["npm", "yarn", "pnpm"]}>
      ```bash filename="terminal"
      npm install @clerk/nextjs @supabase/supabase-js
      ```

      ```bash filename="terminal"
      yarn add @clerk/nextjs @supabase/supabase-js
      ```

      ```bash filename="terminal"
      pnpm add @clerk/nextjs @supabase/supabase-js
      ```
    </CodeBlockTabs>
  </Tab>
  <Tab>
    <CodeBlockTabs type="installer" options={["npm", "yarn", "pnpm"]}>
      ```bash filename="terminal"
      npm install @clerk/clerk-react @supabase/supabase-js
      ```

      ```bash filename="terminal"
      yarn add @clerk/clerk-react @supabase/supabase-js
      ```

      ```bash filename="terminal"
      pnpm add @clerk/clerk-react @supabase/supabase-js
      ```
    </CodeBlockTabs>
  </Tab>
</Tabs>

Then, set up your environment variables:

1. If you don't have a `.env.local` file in the root directory of your Next.js project, create one now.
1. Find your Clerk publishable key and secret key. If you're signed into Clerk, the `.env.local` snippet below will contain your keys. Otherwise:
    - Navigate to your Clerk Dashboard(opens in a new tab).
    - Select your application, then select ðŸ”‘ API Keys in the sidebar menu.
    - You can copy your keys from the Quick Copy section.
1. Add your keys to your `.env.local` file.
1. Find your Supabase credentials.:
    - Go to your Supabase dashboard. In the sidebar, select **Settings** â†’ **API**.
    - Copy the **Project URL**.
    - Copy the value beside `anon` `public` in the **Project API Keys** section.
1. Add your Supabase credentials to your `.env.local` file.

The final result should resemble the following snippet:

    <InjectKeys>
    <CodeBlockTabs type="framework" options={["Next.js", "React"]}>
    ```js filename=".env.local"
    NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
    NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
    NEXT_PUBLIC_SUPABASE_KEY=your-supabase-anon-key
    ```
    ```js filename=".env.local"
    REACT_APP_CLERK_PUBLISHABLE_KEY={{pub_key}}
    REACT_APP_SUPABASE_URL=your-supabase-url
    REACT_APP_SUPABASE_KEY=your-supabase-anon-key
    ```
    </CodeBlockTabs>      
    </InjectKeys>

### Fetch Supabase data in your code 

1. Create a component in your app and define a client object that can connect to your database:
    <CodeBlockTabs type="framework" options={["Next.js", "React"]}>
    ```ts filename="app/supabase/page.tsx"
    import { useAuth } from '@clerk/clerk-react';
    import { createClient } from "@supabase/supabase-js";
    
    // Uses the JWT passed to it to initialize the client object.
    // This JWT will come from your JWT template, and be sent
    // with all requests to supabase.
    const supabaseClient = async (supabaseAccessToken) => {
        const supabase = createClient(
          process.env.NEXT_PUBLIC_SUPABASE_URL,
          process.env.NEXT_PUBLIC_SUPABASE_KEY,
          {
            global: { 
              headers: { 
                Authorization:c `Bearer ${supabaseAccessToken}`
              }
            },
        });
        return supabase;
      };
    ```
    ```ts filename="components/supabase.tsx"
    import { useAuth } from '@clerk/clerk-react';
    import { createClient } from "@supabase/supabase-js";
    
    // Uses the JWT passed to it to initialize the client object.
    // This JWT will come from your JWT template, and be sent
    // with all requests to supabase.
    const supabaseClient = async (supabaseAccessToken) => {
        const supabase = createClient(
          process.env.REACT_APP_SUPABASE_URL,
          process.env.REACT_APP_SUPABASE_KEY,
          {
            global: { 
              headers: { 
                Authorization: `Bearer ${supabaseAccessToken}`
              }
            },
        });
        return supabase;
      };
    ```
    </CodeBlockTabs>
1. Next, define a component that:
    - Calls `useAuth()` to require authentication to access the page.
    - Defines a function that gets a generated token from your JWT template and uses it to fetch the contents of a table in your database.
    <CodeBlockTabs type="framework" options={["Next.js", "React"]}>
    ```tsx filename="app/supabase/page.tsx"
    export default function Supabase() {
      const { getToken } = useAuth();

      const [dbData, setDbData] = useState<any>(null);
      const [dbError, setDbError] = useState<any>(null);

      const fetchData = async () => {
        // Replace with your JWT template name
        const supabaseAccessToken = await getToken({ template: "supabase" });
        const supabase = await supabaseClient(supabaseAccessToken);

        // Replace "your_table" with your database table name
        const { data, error } = await supabase.from("your_table").select();

        // Handle the response
        console.log("Data", data);
        console.log("-------------");
        console.log("Error", error);

        setDbData(data);
        setDbError(error);
      };

      return null;
    }
    ```
    ```tsx filename="components/supabase.tsx"
    export default function Supabase() {
      const { getToken } = useAuth();

      const [dbData, setDbData] = useState<any>(null);
      const [dbError, setDbError] = useState<any>(null);

      const fetchData = async () => {
        // Replace with your JWT template name
        const supabaseAccessToken = await getToken({ template: "supabase" });
        const supabase = await supabaseClient(supabaseAccessToken);

        // Replace "your_table" with your database table name
        const { data, error } = await supabase.from("your_table").select();

        // Handle the response
        console.log("Data", data);
        console.log("-------------");
        console.log("Error", error);

        setDbData(data);
        setDbError(error);
      };

      return null;
    }
    ```
    </CodeBlockTabs>
1. Finally, edit your component to return a basic UI that allows you to call `fetchData()` with a button:
    <CodeBlockTabs type="framework" options={["Next.js", "React"]}>
    ```tsx filename="app/supabase/page.tsx"
    return (
      <>
        <div>
          <button onClick={fetchData}>Fetch data</button>
        </div>
        <h2>Data</h2>
        <p>
          {Boolean(dbData?.length)
            ? JSON.stringify(dbData, null, 2)
            : "No data"}
        </p>
        <h2>Errors</h2>
        <p>
          {Boolean(dbError?.length)
            ? JSON.stringify(dbError, null, 2)
            : "No errors"}
        </p>
      </>
    );
    ```
    ```tsx filename="components/supabase.tsx"
    return (
      <>
        <div>
          <button onClick={fetchData}>Fetch data</button>
        </div>
        <h2>Data</h2>
        <p>
          {Boolean(dbData?.length)
            ? JSON.stringify(dbData, null, 2)
            : "No data"}
        </p>
        <h2>Errors</h2>
        <p>
          {Boolean(dbError?.length)
            ? JSON.stringify(dbError, null, 2)
            : "No errors"}
        </p>
      </>
    );
    ```
    </CodeBlockTabs>
1. The final result should be similar to this:
    <CodeBlockTabs type="framework" options={["Next.js", "React"]}>
    ```ts filename="app/supabase/page.tsx"
    import { useAuth } from '@clerk/clerk-react';
    import { createClient } from "@supabase/supabase-js";
    
    // Uses the JWT passed to it to initialize the client object.
    // This JWT will come from your JWT template, and be sent
    // with all requests to supabase.
    const supabaseClient = async (supabaseAccessToken) => {
      const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL,
        process.env.NEXT_PUBLIC_SUPABASE_KEY,
        {
          global: { 
            headers: { 
              Authorization:c `Bearer ${supabaseAccessToken}`
            }
          },
      });
      return supabase;
    };

    export default function Supabase() {
      const { getToken } = useAuth();

      const [dbData, setDbData] = useState<any>(null);
      const [dbError, setDbError] = useState<any>(null);

      const fetchData = async () => {
        // Replace with your JWT template name
        const supabaseAccessToken = await getToken({ template: "supabase" });
        const supabase = await supabaseClient(supabaseAccessToken);

        // Replace "your_table" with your database table name
        const { data, error } = await supabase.from("your_table").select();

        // Handle the response
        console.log("Data", data);
        console.log("-------------");
        console.log("Error", error);

        setDbData(data);
        setDbError(error);
      };

      return (
        <>
          <div>
            <button onClick={fetchData}>Fetch data</button>
          </div>
          <h2>Data</h2>
          <p>
            {Boolean(dbData?.length)
              ? JSON.stringify(dbData, null, 2)
              : "No data"}
          </p>
          <h2>Errors</h2>
          <p>
            {Boolean(dbError?.length)
              ? JSON.stringify(dbError, null, 2)
              : "No errors"}
          </p>
        </>
      );
    }
    ```
    ```ts filename="components/supabase.tsx"
    import { useAuth } from '@clerk/clerk-react';
    import { createClient } from "@supabase/supabase-js";
    
    // Uses the JWT passed to it to initialize the client object.
    // This JWT will come from your JWT template, and be sent
    // with all requests to supabase.
    const supabaseClient = async (supabaseAccessToken) => {
      const supabase = createClient(
        process.env.REACT_APP_SUPABASE_URL,
        process.env.REACT_APP_SUPABASE_KEY,
        {
          global: { 
            headers: { 
              Authorization:c `Bearer ${supabaseAccessToken}`
            }
          },
      });
      return supabase;
    };
    
    export default function Supabase() {
      const { getToken } = useAuth();

      const [dbData, setDbData] = useState<any>(null);
      const [dbError, setDbError] = useState<any>(null);

      const fetchData = async () => {
        // Replace with your JWT template name
        const supabaseAccessToken = await getToken({ template: "supabase" });
        const supabase = await supabaseClient(supabaseAccessToken);

        // Replace "your_table" with your database table name
        const { data, error } = await supabase.from("your_table").select();

        // Handle the response
        console.log("Data", data);
        console.log("-------------");
        console.log("Error", error);

        setDbData(data);
        setDbError(error);
      };
      
      return (
        <>
          <div>
            <button onClick={fetchData}>Fetch data</button>
          </div>
          <h2>Data</h2>
          <p>
            {Boolean(dbData?.length)
              ? JSON.stringify(dbData, null, 2)
              : "No data"}
          </p>
          <h2>Errors</h2>
          <p>
            {Boolean(dbError?.length)
              ? JSON.stringify(dbError, null, 2)
              : "No errors"}
          </p>
        </>
      );
    }
    ```
    </CodeBlockTabs>
1. Build and run your application. When you visit the page with your component, you'll be required to sign in. Press the **Fetch data** data button, and the contents of your table should be displayed below it.

To learn how to show users only data associated with their user ID, see the section on RLS policies below.
</Steps>

## Access user ID in RLS policies

It is common practice to need access to the user identifier on the database level, especially when working with RLS policies in Postgres. Although Supabase provides a special function `auth.uid()` to extract the user ID from the JWT, this [does not currently work](https://github.com/orgs/supabase/discussions/4954) with Clerk. The workaround is to write a custom SQL function to read the sub property from the JWT claims.

In the **SQL Editor** section of the Supabase dashboard, click New Query and enter the following:

```json
create or replace function requesting_user_id()
returns text 
language sql stable
as $$
  select nullif(current_setting('request.jwt.claims', true)::json->>'sub', '')::text;
$$;
```

This will create a `requesting_user_id()` function that can be used within an RLS policy.

For example, this policy would check that the user making the request is authenticated and matches the `user_id` column of a todos table.

```json
CREATE POLICY "Authenticated users can update their own todos" 
	ON public.todos FOR UPDATE USING (
		auth.role() = 'authenticated'::text
	) WITH CHECK (
		requesting_user_id() = user_id
	);
```

## Next steps

- Get started with Clerk's official [clerk-supabase-starter](https://github.com/clerk/clerk-supabase-starter) repo
- Check out Clerk's [Next.js + Supabase + Clerk tutorial](https://clerk.com/blog/nextjs-supabase-todos-with-multifactor-authentication)
- Try adding some [custom claims](/docs/backend-requests/making/jwt-templates) to the JWT template in `app_metadata` or `user_metadata`